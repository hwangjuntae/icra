#!/usr/bin/env python3
"""
위험도 평가 결과를 바탕으로 Risk Map을 생성하는 ROS2 노드
"""

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image, LaserScan
from nav_msgs.msg import OccupancyGrid
from geometry_msgs.msg import PoseStamped, Point
from std_msgs.msg import Header
import cv2
import numpy as np
import json
import time
import math
import threading
from collections import deque
import tf2_ros
from tf2_ros import TransformListener, Buffer
import tf2_geometry_msgs

# cv_bridge import
try:
    from cv_bridge import CvBridge
    CV_BRIDGE_AVAILABLE = True
except ImportError:
    print("cv_bridge 패키지가 없습니다. ros-humble-cv-bridge를 설치해주세요.")
    CV_BRIDGE_AVAILABLE = False

class RiskMappingNode(Node):
    def __init__(self):
        super().__init__('risk_mapping_node')
        
        # cv_bridge 초기화
        if CV_BRIDGE_AVAILABLE:
            self.bridge = CvBridge()
        else:
            self.bridge = None
            self.get_logger().error("cv_bridge를 사용할 수 없습니다.")
        
        # 위험도 평가 결과 구독
        self.risk_image_subscription = self.create_subscription(
            Image,
            '/risk_assessment/image',
            self.risk_image_callback,
            10
        )
        
        # LiDAR 구독
        self.scan_subscription = self.create_subscription(
            LaserScan,
            '/Lidar/laser_scan',
            self.scan_callback,
            10
        )
        
        # Risk Map 발행
        self.risk_map_publisher = self.create_publisher(
            OccupancyGrid,
            '/risk_map',
            10
        )
        
        # TF2 리스너 초기화
        self.tf_buffer = Buffer()
        self.tf_listener = TransformListener(self.tf_buffer, self)
        
        # 맵 설정
        self.map_resolution = 0.1  # 10cm per pixel
        self.map_width = 500       # 50m x 50m
        self.map_height = 500
        self.map_origin_x = -25.0   # base_link 기준 (맵의 왼쪽 하단)
        self.map_origin_y = -25.0   # base_link 기준 (맵의 왼쪽 하단)
        
        # 위험도 맵 초기화
        self.risk_map = np.zeros((self.map_height, self.map_width), dtype=np.float32)
        self.occupancy_map = np.zeros((self.map_height, self.map_width), dtype=np.int8)
        
        # 테스트용 위험도 데이터 추가 (맵 중앙에)
        center_x, center_y = self.map_width // 2, self.map_height // 2
        test_radius = 50
        
        # 간단한 원형 테스트 데이터 추가
        for i in range(max(0, center_x - test_radius), min(self.map_width, center_x + test_radius)):
            for j in range(max(0, center_y - test_radius), min(self.map_height, center_y + test_radius)):
                distance = np.sqrt((i - center_x)**2 + (j - center_y)**2)
                if distance <= test_radius:
                    self.risk_map[j, i] = max(0, 50 - distance)  # 중앙에서 멀어질수록 위험도 감소
        
        # 초기 테스트 데이터 로그
        self.get_logger().info(f"테스트 데이터 추가: 중앙({center_x}, {center_y}), 반지름: {test_radius}")
        self.get_logger().info(f"초기 위험도 맵 최대값: {np.max(self.risk_map):.1f}")
        self.get_logger().info(f"초기 위험도 맵 0이 아닌 픽셀 수: {np.sum(self.risk_map > 0)}")
        
        # 추가 테스트: 맵의 일부 영역에 고정 데이터 추가
        test_area_size = 100
        start_x = center_x - test_area_size // 2
        start_y = center_y - test_area_size // 2
        end_x = start_x + test_area_size
        end_y = start_y + test_area_size
        
        for i in range(start_x, end_x):
            for j in range(start_y, end_y):
                if 0 <= i < self.map_width and 0 <= j < self.map_height:
                    self.risk_map[j, i] = 30  # 고정 위험도 값
        
        # 위험도 설정
        self.risk_levels = {
            "low": 25,
            "medium": 50,
            "high": 75
        }
        
        # 시간 기반 위험도 감쇠
        self.risk_decay_rate = 0.95  # 매 프레임마다 5% 감쇠
        self.max_risk_age = 30.0     # 30초 후 위험도 제거
        
        # 위험도 히스토리 (시간 기반 감쇠용)
        self.risk_history = deque(maxlen=1000)
        
        # 최신 데이터 저장
        self.latest_risk_data = None
        self.latest_scan = None
        self.latest_robot_pose = None
        
        # 성능 모니터링
        self.processing_times = []
        self.max_time_samples = 10
        
        # 타이머 생성 (1Hz로 맵 업데이트)
        self.map_update_timer = self.create_timer(1.0, self.update_risk_map)
        
        # 초기화 완료 메시지
        self.get_logger().info("Risk Mapping 노드 시작")
        self.get_logger().info(f"맵 크기: {self.map_width}x{self.map_height} ({self.map_width * self.map_resolution:.1f}m x {self.map_height * self.map_resolution:.1f}m)")
        self.get_logger().info(f"맵 해상도: {self.map_resolution}m/pixel")
        self.get_logger().info(f"위험도 감쇠율: {self.risk_decay_rate:.2f}")
        self.get_logger().info("구독 토픽: /risk_assessment/image, /Lidar/laser_scan")
        self.get_logger().info("발행 토픽: /risk_map (OccupancyGrid)")
        
    def risk_image_callback(self, msg):
        """위험도 평가 결과 이미지 콜백"""
        try:
            if self.bridge is None:
                return
                
            # 이미지를 OpenCV 형식으로 변환
            cv_image = self.bridge.imgmsg_to_cv2(msg, "bgr8")
            
            # 위험도 정보 추출
            risk_data = self.extract_risk_data_from_image(cv_image)
            
            if risk_data:
                self.latest_risk_data = risk_data
                self.get_logger().debug(f"위험도 데이터 추출: {len(risk_data.get('detections', []))}개 객체")
                
        except Exception as e:
            self.get_logger().error(f"위험도 이미지 처리 오류: {str(e)}")
            
    def extract_risk_data_from_image(self, image):
        """이미지에서 위험도 데이터 추출 (시각적 분석)"""
        try:
            # 이미지 크기
            height, width = image.shape[:2]
            
            # 색상 기반 위험도 탐지
            risk_detections = []
            
            # 위험도 레벨별 색상 (BGR)
            color_map = {
                "low": (0, 255, 0),      # 녹색
                "medium": (0, 255, 255), # 노란색
                "high": (0, 0, 255)      # 빨간색
            }
            
            # 각 색상 범위에서 객체 탐지
            for risk_level, color in color_map.items():
                # 색상 마스크 생성 (더 관대한 범위)
                lower_color = np.array([max(0, c-50) for c in color])
                upper_color = np.array([min(255, c+50) for c in color])
                
                mask = cv2.inRange(image, lower_color, upper_color)
                
                # 모폴로지 연산으로 노이즈 제거
                kernel = np.ones((3,3), np.uint8)
                mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
                mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
                
                # 윤곽선 찾기
                contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
                
                for contour in contours:
                    # 최소 크기 필터링 (더 작은 크기 허용)
                    if cv2.contourArea(contour) > 50:
                        x, y, w, h = cv2.boundingRect(contour)
                        
                        # 바운딩 박스 중심점
                        center_x = x + w // 2
                        center_y = y + h // 2
                        
                        # 위험도 점수 계산
                        risk_score = self.risk_levels.get(risk_level, 25)
                        
                        detection = {
                            "bbox": {
                                "x1": float(x),
                                "y1": float(y),
                                "x2": float(x + w),
                                "y2": float(y + h)
                            },
                            "center": (center_x, center_y),
                            "risk_score": risk_score,
                            "risk_level": risk_level,
                            "confidence": 0.8  # 기본 신뢰도
                        }
                        
                        risk_detections.append(detection)
            
            # 디버그 정보 추가
            if risk_detections:
                self.get_logger().info(f"위험도 객체 탐지: {len(risk_detections)}개")
            else:
                # 색상 통계 출력 (디버그용)
                hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
                green_pixels = cv2.inRange(hsv, np.array([40, 40, 40]), np.array([80, 255, 255]))
                yellow_pixels = cv2.inRange(hsv, np.array([20, 100, 100]), np.array([30, 255, 255]))
                red_pixels = cv2.inRange(hsv, np.array([0, 100, 100]), np.array([10, 255, 255]))
                
                green_count = np.sum(green_pixels > 0)
                yellow_count = np.sum(yellow_pixels > 0)
                red_count = np.sum(red_pixels > 0)
                
                self.get_logger().debug(f"색상 픽셀 수: 녹색={green_count}, 노란색={yellow_count}, 빨간색={red_count}")
                
                # 텍스트 기반 위험도 탐지 (대안)
                risk_detections = self.extract_risk_from_text(image)
            
            return {
                "timestamp": time.time(),
                "detections": risk_detections,
                "image_size": (width, height)
            }
                
        except Exception as e:
            self.get_logger().error(f"위험도 데이터 추출 오류: {str(e)}")
            return None
            
    def extract_risk_from_text(self, image):
        """텍스트 기반 위험도 탐지 (대안)"""
        try:
            # 이미지에서 텍스트 영역 찾기 (바운딩 박스 형태)
            gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
            
            # 엣지 검출
            edges = cv2.Canny(gray, 50, 150)
            
            # 윤곽선 찾기
            contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            
            risk_detections = []
            
            for contour in contours:
                # 사각형 형태의 윤곽선만 선택
                if cv2.contourArea(contour) > 1000:  # 충분히 큰 영역
                    x, y, w, h = cv2.boundingRect(contour)
                    
                    # 종횡비 확인 (텍스트 박스는 보통 가로가 길다)
                    aspect_ratio = w / h
                    if 1.5 < aspect_ratio < 10:  # 텍스트 박스 비율
                        
                        # 해당 영역의 색상 분석
                        roi = image[y:y+h, x:x+w]
                        if roi.size > 0:
                            # 평균 색상 계산
                            mean_color = np.mean(roi, axis=(0, 1))
                            
                            # 색상에 따른 위험도 결정
                            risk_level = "low"
                            risk_score = 25
                            
                            # BGR 순서로 색상 분석
                            if mean_color[2] > 150 and mean_color[1] < 100:  # 빨간색
                                risk_level = "high"
                                risk_score = 75
                            elif mean_color[1] > 150 and mean_color[2] > 150:  # 노란색
                                risk_level = "medium"
                                risk_score = 50
                            elif mean_color[1] > 150 and mean_color[0] < 100:  # 녹색
                                risk_level = "low"
                                risk_score = 25
                            
                            detection = {
                                "bbox": {
                                    "x1": float(x),
                                    "y1": float(y),
                                    "x2": float(x + w),
                                    "y2": float(y + h)
                                },
                                "center": (x + w // 2, y + h // 2),
                                "risk_score": risk_score,
                                "risk_level": risk_level,
                                "confidence": 0.6
                            }
                            
                            risk_detections.append(detection)
            
            if risk_detections:
                self.get_logger().info(f"텍스트 기반 위험도 탐지: {len(risk_detections)}개")
            
            return risk_detections
                    
        except Exception as e:
            self.get_logger().error(f"텍스트 기반 위험도 탐지 오류: {str(e)}")
            return []
            
    def scan_callback(self, msg):
        """LiDAR 콜백"""
        self.latest_scan = msg
        
    def update_risk_map(self):
        """Risk Map 업데이트"""
        start_time = time.time()
        
        try:
            # 위험도 감쇠 적용
            self.apply_risk_decay()
            
            # 새로운 위험도 추가 (데이터가 있을 때만)
            if self.latest_risk_data is not None and self.latest_scan is not None:
                self.add_new_risks()
            
            # 맵 발행
            self.publish_risk_map()
            
            # 성능 통계 업데이트
            processing_time = (time.time() - start_time) * 1000
            self.update_performance_stats(processing_time)
            
            # 통계 로그
            stats = self.get_risk_statistics()
            self.get_logger().info(f"Risk Map 업데이트: {stats} | 처리시간: {processing_time:.1f}ms")
                
        except Exception as e:
            self.get_logger().error(f"Risk Map 업데이트 오류: {str(e)}")
            import traceback
            traceback.print_exc()
            
    def apply_risk_decay(self):
        """시간 기반 위험도 감쇠 적용"""
        current_time = time.time()
        
        # 맵 전체에 감쇠 적용 (테스트 데이터는 보존)
        decay_mask = self.risk_map > 0
        self.risk_map[decay_mask] *= self.risk_decay_rate
        
        # 오래된 위험도 제거 (최소값을 높여서 테스트 데이터 보존)
        self.risk_map[self.risk_map < 5.0] = 0.0
        
        # 히스토리에서 오래된 항목 제거
        while self.risk_history and (current_time - self.risk_history[0]['timestamp']) > self.max_risk_age:
            self.risk_history.popleft()
            
    def add_new_risks(self):
        """새로운 위험도 추가"""
        if not self.latest_risk_data:
            return
            
        current_time = time.time()
        
        for detection in self.latest_risk_data.get('detections', []):
            # 이미지 좌표를 월드 좌표로 변환
            world_pos = self.image_to_world_coordinates(
                detection['center'][0],
                detection['center'][1],
                detection['bbox']
            )
            
            if world_pos:
                # 맵 좌표로 변환
                map_x, map_y = self.world_to_map_coordinates(world_pos[0], world_pos[1])
                
                if self.is_valid_map_coordinates(map_x, map_y):
                    # 위험도 추가
                    risk_value = detection['risk_score']
                    
                    # 기존 위험도와 비교하여 더 높은 값으로 설정
                    self.risk_map[map_y, map_x] = max(self.risk_map[map_y, map_x], risk_value)
                    
                    # 히스토리에 추가
                    self.risk_history.append({
                        'timestamp': current_time,
                        'map_x': map_x,
                        'map_y': map_y,
                        'risk_value': risk_value,
                        'world_pos': world_pos
                    })
                    
    def image_to_world_coordinates(self, img_x, img_y, bbox):
        """이미지 좌표를 월드 좌표로 변환"""
        try:
            if self.latest_scan is None:
                return None
                
            # 이미지 중심에서의 상대적 위치
            img_width = self.latest_risk_data['image_size'][0]
            img_height = self.latest_risk_data['image_size'][1]
            
            # 정규화된 좌표 (-1 to 1)
            rel_x = (img_x / img_width) * 2.0 - 1.0  # -1 (왼쪽) to 1 (오른쪽)
            rel_y = (img_y / img_height) * 2.0 - 1.0  # -1 (위쪽) to 1 (아래쪽)
            
            # 카메라 시야각 (라디안)
            camera_hfov = math.radians(90.0)  # 90도
            camera_vfov = math.radians(67.5)  # 67.5도 (4:3 비율)
            
            # 각도 계산
            angle_x = rel_x * camera_hfov / 2.0
            angle_y = rel_y * camera_vfov / 2.0
            
            # LiDAR에서 거리 찾기
            distance = self.find_lidar_distance(angle_x)
            
            if distance is not None and distance > 0:
                # 월드 좌표 계산
                world_x = distance * math.sin(angle_x)
                world_y = distance * math.cos(angle_x)
                world_z = distance * math.sin(angle_y)
                
                return (world_x, world_y, world_z)
                
        except Exception as e:
            self.get_logger().debug(f"좌표 변환 오류: {str(e)}")
            
        return None
        
    def find_lidar_distance(self, angle_x):
        """LiDAR에서 특정 각도의 거리 찾기"""
        try:
            if self.latest_scan is None:
                return None
            
            # 라이다 인덱스 계산
            if self.latest_scan.angle_increment != 0:
                idx = int((angle_x - self.latest_scan.angle_min) / self.latest_scan.angle_increment)
                
                if 0 <= idx < len(self.latest_scan.ranges):
                    distance = self.latest_scan.ranges[idx]
                    
                    # 유효한 거리인지 확인
                    if not math.isnan(distance) and distance > 0 and distance < self.latest_scan.range_max:
                        return distance
                        
        except Exception as e:
            self.get_logger().debug(f"LiDAR 거리 계산 오류: {str(e)}")
            
        return None
        
    def world_to_map_coordinates(self, world_x, world_y):
        """월드 좌표를 맵 좌표로 변환"""
        map_x = int((world_x - self.map_origin_x) / self.map_resolution)
        map_y = int((world_y - self.map_origin_y) / self.map_resolution)
        return map_x, map_y
        
    def is_valid_map_coordinates(self, map_x, map_y):
        """맵 좌표가 유효한지 확인"""
        return 0 <= map_x < self.map_width and 0 <= map_y < self.map_height
        
    def publish_risk_map(self):
        """Risk Map을 OccupancyGrid로 발행"""
        try:
            # 간단한 테스트 데이터 생성
            occupancy_data = np.zeros((self.map_height, self.map_width), dtype=np.int8)
            
            # 실제 위험도 데이터를 맵에 반영
            if hasattr(self, 'latest_risk_data') and self.latest_risk_data:
                for detection in self.latest_risk_data.get('detections', []):
                    # 이미지 좌표를 월드 좌표로 변환
                    img_center = detection['center']
                    world_coords = self.image_to_world_coordinates(img_center[0], img_center[1])
                    
                    if world_coords:
                        world_x, world_y, _ = world_coords
                        map_x, map_y = self.world_to_map_coordinates(world_x, world_y)
                        
                        if self.is_valid_map_coordinates(map_x, map_y):
                            # 위험도 점수를 맵에 반영
                            risk_score = detection.get('risk_score', 25)
                            risk_value = min(100, max(0, risk_score))
                            
                            # 위험도 영역을 맵에 그리기
                            radius = 10  # 위험도 영역 반지름
                            for i in range(max(0, map_x - radius), min(self.map_width, map_x + radius)):
                                for j in range(max(0, map_y - radius), min(self.map_height, map_y + radius)):
                                    distance = np.sqrt((i - map_x)**2 + (j - map_y)**2)
                                    if distance <= radius:
                                        occupancy_data[j, i] = risk_value
                            
                            self.get_logger().info(f"위험도 맵에 추가: ({map_x}, {map_y}) - 점수: {risk_value}")
            
            # 테스트 데이터 (실제 데이터가 없을 때)
            if np.sum(occupancy_data) == 0:
                center_x, center_y = self.map_width // 2, self.map_height // 2
                radius = 30
                
                for i in range(max(0, center_x - radius), min(self.map_width, center_x + radius)):
                    for j in range(max(0, center_y - radius), min(self.map_height, center_y + radius)):
                        distance = np.sqrt((i - center_x)**2 + (j - center_y)**2)
                        if distance <= radius:
                            occupancy_data[j, i] = 50
                
                # 맵 경계선 추가
                occupancy_data[0, :] = 25
                occupancy_data[-1, :] = 25
                occupancy_data[:, 0] = 25
                occupancy_data[:, -1] = 25
            
            # 디버그: 실제로 데이터가 추가되었는지 확인
            self.get_logger().info(f"원형 테스트 영역: 중심({center_x},{center_y}), 반지름: {radius}")
            self.get_logger().info(f"추가된 픽셀 수: {np.sum(occupancy_data > 0)}")
            
            # 맵 메타데이터
            header = Header()
            header.stamp = self.get_clock().now().to_msg()
            header.frame_id = "base_link"  # base_link 프레임으로 변경
            
            # 맵 정보
            map_info = OccupancyGrid()
            map_info.header = header
            map_info.info.resolution = self.map_resolution
            map_info.info.width = self.map_width
            map_info.info.height = self.map_height
            map_info.info.origin.position.x = self.map_origin_x
            map_info.info.origin.position.y = self.map_origin_y
            map_info.info.origin.position.z = 0.0
            map_info.info.origin.orientation.w = 1.0
            
            # 맵 데이터 (1차원 배열로 변환)
            map_data = occupancy_data.flatten().tolist()
            map_info.data = map_data
            
            # 발행
            self.risk_map_publisher.publish(map_info)
            
            # 디버그 정보
            max_risk = np.max(occupancy_data)
            non_zero_count = np.sum(occupancy_data > 0)
            self.get_logger().info(f"Risk Map 발행: 최대값={max_risk}, 0이 아닌 픽셀={non_zero_count}, 총 픽셀={len(map_data)}")
            
            # 추가 디버그: 실제 데이터 확인
            if non_zero_count > 0:
                self.get_logger().info(f"테스트 데이터가 성공적으로 추가됨: {non_zero_count}개 픽셀")
            else:
                self.get_logger().warn("테스트 데이터가 추가되지 않음!")
                
        except Exception as e:
            self.get_logger().error(f"Risk Map 발행 오류: {str(e)}")
            import traceback
            traceback.print_exc()
            
    def update_performance_stats(self, processing_time):
        """성능 통계 업데이트"""
        self.processing_times.append(processing_time)
        
        # 최대 샘플 수 유지
        if len(self.processing_times) > self.max_time_samples:
            self.processing_times.pop(0)
            
    def get_risk_statistics(self):
        """위험도 통계 반환"""
        if np.max(self.risk_map) == 0:
            return "위험도 없음"
            
        max_risk = np.max(self.risk_map)
        avg_risk = np.mean(self.risk_map[self.risk_map > 0])
        risk_pixels = np.sum(self.risk_map > 0)
        total_pixels = self.risk_map.size
        
        return f"최대 위험도: {max_risk:.1f}, 평균 위험도: {avg_risk:.1f}, 위험 픽셀: {risk_pixels}/{total_pixels}"

def main(args=None):
    rclpy.init(args=args)
    node = None
    
    try:
        node = RiskMappingNode()
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f"노드 실행 오류: {str(e)}")
    finally:
        try:
            if rclpy.ok():
                rclpy.shutdown()
        except Exception as e:
            print(f"rclpy 종료 오류 (무시됨): {str(e)}")

if __name__ == '__main__':
    main()
 